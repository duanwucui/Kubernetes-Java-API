/*
 * Kubernetes
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.7.8
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.github.patrickianwilson.thirdparty.kubernetes.model;

import java.util.Objects;
import com.github.patrickianwilson.thirdparty.kubernetes.model.IoK8sKubernetesPkgApiV1AWSElasticBlockStoreVolumeSource;
import com.github.patrickianwilson.thirdparty.kubernetes.model.IoK8sKubernetesPkgApiV1AzureDiskVolumeSource;
import com.github.patrickianwilson.thirdparty.kubernetes.model.IoK8sKubernetesPkgApiV1AzureFileVolumeSource;
import com.github.patrickianwilson.thirdparty.kubernetes.model.IoK8sKubernetesPkgApiV1CephFSVolumeSource;
import com.github.patrickianwilson.thirdparty.kubernetes.model.IoK8sKubernetesPkgApiV1CinderVolumeSource;
import com.github.patrickianwilson.thirdparty.kubernetes.model.IoK8sKubernetesPkgApiV1ConfigMapVolumeSource;
import com.github.patrickianwilson.thirdparty.kubernetes.model.IoK8sKubernetesPkgApiV1DownwardAPIVolumeSource;
import com.github.patrickianwilson.thirdparty.kubernetes.model.IoK8sKubernetesPkgApiV1EmptyDirVolumeSource;
import com.github.patrickianwilson.thirdparty.kubernetes.model.IoK8sKubernetesPkgApiV1FCVolumeSource;
import com.github.patrickianwilson.thirdparty.kubernetes.model.IoK8sKubernetesPkgApiV1FlexVolumeSource;
import com.github.patrickianwilson.thirdparty.kubernetes.model.IoK8sKubernetesPkgApiV1FlockerVolumeSource;
import com.github.patrickianwilson.thirdparty.kubernetes.model.IoK8sKubernetesPkgApiV1GCEPersistentDiskVolumeSource;
import com.github.patrickianwilson.thirdparty.kubernetes.model.IoK8sKubernetesPkgApiV1GitRepoVolumeSource;
import com.github.patrickianwilson.thirdparty.kubernetes.model.IoK8sKubernetesPkgApiV1GlusterfsVolumeSource;
import com.github.patrickianwilson.thirdparty.kubernetes.model.IoK8sKubernetesPkgApiV1HostPathVolumeSource;
import com.github.patrickianwilson.thirdparty.kubernetes.model.IoK8sKubernetesPkgApiV1ISCSIVolumeSource;
import com.github.patrickianwilson.thirdparty.kubernetes.model.IoK8sKubernetesPkgApiV1NFSVolumeSource;
import com.github.patrickianwilson.thirdparty.kubernetes.model.IoK8sKubernetesPkgApiV1PersistentVolumeClaimVolumeSource;
import com.github.patrickianwilson.thirdparty.kubernetes.model.IoK8sKubernetesPkgApiV1PhotonPersistentDiskVolumeSource;
import com.github.patrickianwilson.thirdparty.kubernetes.model.IoK8sKubernetesPkgApiV1PortworxVolumeSource;
import com.github.patrickianwilson.thirdparty.kubernetes.model.IoK8sKubernetesPkgApiV1ProjectedVolumeSource;
import com.github.patrickianwilson.thirdparty.kubernetes.model.IoK8sKubernetesPkgApiV1QuobyteVolumeSource;
import com.github.patrickianwilson.thirdparty.kubernetes.model.IoK8sKubernetesPkgApiV1RBDVolumeSource;
import com.github.patrickianwilson.thirdparty.kubernetes.model.IoK8sKubernetesPkgApiV1ScaleIOVolumeSource;
import com.github.patrickianwilson.thirdparty.kubernetes.model.IoK8sKubernetesPkgApiV1SecretVolumeSource;
import com.github.patrickianwilson.thirdparty.kubernetes.model.IoK8sKubernetesPkgApiV1StorageOSVolumeSource;
import com.github.patrickianwilson.thirdparty.kubernetes.model.IoK8sKubernetesPkgApiV1VsphereVirtualDiskVolumeSource;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 */
@ApiModel(description = "Volume represents a named volume in a pod that may be accessed by any container in the pod.")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2017-11-17T08:08:12.703-08:00")
public class IoK8sKubernetesPkgApiV1Volume {
  @SerializedName("awsElasticBlockStore")
  private IoK8sKubernetesPkgApiV1AWSElasticBlockStoreVolumeSource awsElasticBlockStore = null;

  @SerializedName("azureDisk")
  private IoK8sKubernetesPkgApiV1AzureDiskVolumeSource azureDisk = null;

  @SerializedName("azureFile")
  private IoK8sKubernetesPkgApiV1AzureFileVolumeSource azureFile = null;

  @SerializedName("cephfs")
  private IoK8sKubernetesPkgApiV1CephFSVolumeSource cephfs = null;

  @SerializedName("cinder")
  private IoK8sKubernetesPkgApiV1CinderVolumeSource cinder = null;

  @SerializedName("configMap")
  private IoK8sKubernetesPkgApiV1ConfigMapVolumeSource configMap = null;

  @SerializedName("downwardAPI")
  private IoK8sKubernetesPkgApiV1DownwardAPIVolumeSource downwardAPI = null;

  @SerializedName("emptyDir")
  private IoK8sKubernetesPkgApiV1EmptyDirVolumeSource emptyDir = null;

  @SerializedName("fc")
  private IoK8sKubernetesPkgApiV1FCVolumeSource fc = null;

  @SerializedName("flexVolume")
  private IoK8sKubernetesPkgApiV1FlexVolumeSource flexVolume = null;

  @SerializedName("flocker")
  private IoK8sKubernetesPkgApiV1FlockerVolumeSource flocker = null;

  @SerializedName("gcePersistentDisk")
  private IoK8sKubernetesPkgApiV1GCEPersistentDiskVolumeSource gcePersistentDisk = null;

  @SerializedName("gitRepo")
  private IoK8sKubernetesPkgApiV1GitRepoVolumeSource gitRepo = null;

  @SerializedName("glusterfs")
  private IoK8sKubernetesPkgApiV1GlusterfsVolumeSource glusterfs = null;

  @SerializedName("hostPath")
  private IoK8sKubernetesPkgApiV1HostPathVolumeSource hostPath = null;

  @SerializedName("iscsi")
  private IoK8sKubernetesPkgApiV1ISCSIVolumeSource iscsi = null;

  @SerializedName("name")
  private String name = null;

  @SerializedName("nfs")
  private IoK8sKubernetesPkgApiV1NFSVolumeSource nfs = null;

  @SerializedName("persistentVolumeClaim")
  private IoK8sKubernetesPkgApiV1PersistentVolumeClaimVolumeSource persistentVolumeClaim = null;

  @SerializedName("photonPersistentDisk")
  private IoK8sKubernetesPkgApiV1PhotonPersistentDiskVolumeSource photonPersistentDisk = null;

  @SerializedName("portworxVolume")
  private IoK8sKubernetesPkgApiV1PortworxVolumeSource portworxVolume = null;

  @SerializedName("projected")
  private IoK8sKubernetesPkgApiV1ProjectedVolumeSource projected = null;

  @SerializedName("quobyte")
  private IoK8sKubernetesPkgApiV1QuobyteVolumeSource quobyte = null;

  @SerializedName("rbd")
  private IoK8sKubernetesPkgApiV1RBDVolumeSource rbd = null;

  @SerializedName("scaleIO")
  private IoK8sKubernetesPkgApiV1ScaleIOVolumeSource scaleIO = null;

  @SerializedName("secret")
  private IoK8sKubernetesPkgApiV1SecretVolumeSource secret = null;

  @SerializedName("storageos")
  private IoK8sKubernetesPkgApiV1StorageOSVolumeSource storageos = null;

  @SerializedName("vsphereVolume")
  private IoK8sKubernetesPkgApiV1VsphereVirtualDiskVolumeSource vsphereVolume = null;

  public IoK8sKubernetesPkgApiV1Volume awsElasticBlockStore(IoK8sKubernetesPkgApiV1AWSElasticBlockStoreVolumeSource awsElasticBlockStore) {
    this.awsElasticBlockStore = awsElasticBlockStore;
    return this;
  }

   /**
   * AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet&#39;s host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   * @return awsElasticBlockStore
  **/
  @ApiModelProperty(value = "AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore")
  public IoK8sKubernetesPkgApiV1AWSElasticBlockStoreVolumeSource getAwsElasticBlockStore() {
    return awsElasticBlockStore;
  }

  public void setAwsElasticBlockStore(IoK8sKubernetesPkgApiV1AWSElasticBlockStoreVolumeSource awsElasticBlockStore) {
    this.awsElasticBlockStore = awsElasticBlockStore;
  }

  public IoK8sKubernetesPkgApiV1Volume azureDisk(IoK8sKubernetesPkgApiV1AzureDiskVolumeSource azureDisk) {
    this.azureDisk = azureDisk;
    return this;
  }

   /**
   * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   * @return azureDisk
  **/
  @ApiModelProperty(value = "AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.")
  public IoK8sKubernetesPkgApiV1AzureDiskVolumeSource getAzureDisk() {
    return azureDisk;
  }

  public void setAzureDisk(IoK8sKubernetesPkgApiV1AzureDiskVolumeSource azureDisk) {
    this.azureDisk = azureDisk;
  }

  public IoK8sKubernetesPkgApiV1Volume azureFile(IoK8sKubernetesPkgApiV1AzureFileVolumeSource azureFile) {
    this.azureFile = azureFile;
    return this;
  }

   /**
   * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
   * @return azureFile
  **/
  @ApiModelProperty(value = "AzureFile represents an Azure File Service mount on the host and bind mount to the pod.")
  public IoK8sKubernetesPkgApiV1AzureFileVolumeSource getAzureFile() {
    return azureFile;
  }

  public void setAzureFile(IoK8sKubernetesPkgApiV1AzureFileVolumeSource azureFile) {
    this.azureFile = azureFile;
  }

  public IoK8sKubernetesPkgApiV1Volume cephfs(IoK8sKubernetesPkgApiV1CephFSVolumeSource cephfs) {
    this.cephfs = cephfs;
    return this;
  }

   /**
   * CephFS represents a Ceph FS mount on the host that shares a pod&#39;s lifetime
   * @return cephfs
  **/
  @ApiModelProperty(value = "CephFS represents a Ceph FS mount on the host that shares a pod's lifetime")
  public IoK8sKubernetesPkgApiV1CephFSVolumeSource getCephfs() {
    return cephfs;
  }

  public void setCephfs(IoK8sKubernetesPkgApiV1CephFSVolumeSource cephfs) {
    this.cephfs = cephfs;
  }

  public IoK8sKubernetesPkgApiV1Volume cinder(IoK8sKubernetesPkgApiV1CinderVolumeSource cinder) {
    this.cinder = cinder;
    return this;
  }

   /**
   * Cinder represents a cinder volume attached and mounted on kubelets host machine More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
   * @return cinder
  **/
  @ApiModelProperty(value = "Cinder represents a cinder volume attached and mounted on kubelets host machine More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md")
  public IoK8sKubernetesPkgApiV1CinderVolumeSource getCinder() {
    return cinder;
  }

  public void setCinder(IoK8sKubernetesPkgApiV1CinderVolumeSource cinder) {
    this.cinder = cinder;
  }

  public IoK8sKubernetesPkgApiV1Volume configMap(IoK8sKubernetesPkgApiV1ConfigMapVolumeSource configMap) {
    this.configMap = configMap;
    return this;
  }

   /**
   * ConfigMap represents a configMap that should populate this volume
   * @return configMap
  **/
  @ApiModelProperty(value = "ConfigMap represents a configMap that should populate this volume")
  public IoK8sKubernetesPkgApiV1ConfigMapVolumeSource getConfigMap() {
    return configMap;
  }

  public void setConfigMap(IoK8sKubernetesPkgApiV1ConfigMapVolumeSource configMap) {
    this.configMap = configMap;
  }

  public IoK8sKubernetesPkgApiV1Volume downwardAPI(IoK8sKubernetesPkgApiV1DownwardAPIVolumeSource downwardAPI) {
    this.downwardAPI = downwardAPI;
    return this;
  }

   /**
   * DownwardAPI represents downward API about the pod that should populate this volume
   * @return downwardAPI
  **/
  @ApiModelProperty(value = "DownwardAPI represents downward API about the pod that should populate this volume")
  public IoK8sKubernetesPkgApiV1DownwardAPIVolumeSource getDownwardAPI() {
    return downwardAPI;
  }

  public void setDownwardAPI(IoK8sKubernetesPkgApiV1DownwardAPIVolumeSource downwardAPI) {
    this.downwardAPI = downwardAPI;
  }

  public IoK8sKubernetesPkgApiV1Volume emptyDir(IoK8sKubernetesPkgApiV1EmptyDirVolumeSource emptyDir) {
    this.emptyDir = emptyDir;
    return this;
  }

   /**
   * EmptyDir represents a temporary directory that shares a pod&#39;s lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   * @return emptyDir
  **/
  @ApiModelProperty(value = "EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir")
  public IoK8sKubernetesPkgApiV1EmptyDirVolumeSource getEmptyDir() {
    return emptyDir;
  }

  public void setEmptyDir(IoK8sKubernetesPkgApiV1EmptyDirVolumeSource emptyDir) {
    this.emptyDir = emptyDir;
  }

  public IoK8sKubernetesPkgApiV1Volume fc(IoK8sKubernetesPkgApiV1FCVolumeSource fc) {
    this.fc = fc;
    return this;
  }

   /**
   * FC represents a Fibre Channel resource that is attached to a kubelet&#39;s host machine and then exposed to the pod.
   * @return fc
  **/
  @ApiModelProperty(value = "FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.")
  public IoK8sKubernetesPkgApiV1FCVolumeSource getFc() {
    return fc;
  }

  public void setFc(IoK8sKubernetesPkgApiV1FCVolumeSource fc) {
    this.fc = fc;
  }

  public IoK8sKubernetesPkgApiV1Volume flexVolume(IoK8sKubernetesPkgApiV1FlexVolumeSource flexVolume) {
    this.flexVolume = flexVolume;
    return this;
  }

   /**
   * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin. This is an alpha feature and may change in future.
   * @return flexVolume
  **/
  @ApiModelProperty(value = "FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin. This is an alpha feature and may change in future.")
  public IoK8sKubernetesPkgApiV1FlexVolumeSource getFlexVolume() {
    return flexVolume;
  }

  public void setFlexVolume(IoK8sKubernetesPkgApiV1FlexVolumeSource flexVolume) {
    this.flexVolume = flexVolume;
  }

  public IoK8sKubernetesPkgApiV1Volume flocker(IoK8sKubernetesPkgApiV1FlockerVolumeSource flocker) {
    this.flocker = flocker;
    return this;
  }

   /**
   * Flocker represents a Flocker volume attached to a kubelet&#39;s host machine. This depends on the Flocker control service being running
   * @return flocker
  **/
  @ApiModelProperty(value = "Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running")
  public IoK8sKubernetesPkgApiV1FlockerVolumeSource getFlocker() {
    return flocker;
  }

  public void setFlocker(IoK8sKubernetesPkgApiV1FlockerVolumeSource flocker) {
    this.flocker = flocker;
  }

  public IoK8sKubernetesPkgApiV1Volume gcePersistentDisk(IoK8sKubernetesPkgApiV1GCEPersistentDiskVolumeSource gcePersistentDisk) {
    this.gcePersistentDisk = gcePersistentDisk;
    return this;
  }

   /**
   * GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet&#39;s host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * @return gcePersistentDisk
  **/
  @ApiModelProperty(value = "GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk")
  public IoK8sKubernetesPkgApiV1GCEPersistentDiskVolumeSource getGcePersistentDisk() {
    return gcePersistentDisk;
  }

  public void setGcePersistentDisk(IoK8sKubernetesPkgApiV1GCEPersistentDiskVolumeSource gcePersistentDisk) {
    this.gcePersistentDisk = gcePersistentDisk;
  }

  public IoK8sKubernetesPkgApiV1Volume gitRepo(IoK8sKubernetesPkgApiV1GitRepoVolumeSource gitRepo) {
    this.gitRepo = gitRepo;
    return this;
  }

   /**
   * GitRepo represents a git repository at a particular revision.
   * @return gitRepo
  **/
  @ApiModelProperty(value = "GitRepo represents a git repository at a particular revision.")
  public IoK8sKubernetesPkgApiV1GitRepoVolumeSource getGitRepo() {
    return gitRepo;
  }

  public void setGitRepo(IoK8sKubernetesPkgApiV1GitRepoVolumeSource gitRepo) {
    this.gitRepo = gitRepo;
  }

  public IoK8sKubernetesPkgApiV1Volume glusterfs(IoK8sKubernetesPkgApiV1GlusterfsVolumeSource glusterfs) {
    this.glusterfs = glusterfs;
    return this;
  }

   /**
   * Glusterfs represents a Glusterfs mount on the host that shares a pod&#39;s lifetime. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md
   * @return glusterfs
  **/
  @ApiModelProperty(value = "Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md")
  public IoK8sKubernetesPkgApiV1GlusterfsVolumeSource getGlusterfs() {
    return glusterfs;
  }

  public void setGlusterfs(IoK8sKubernetesPkgApiV1GlusterfsVolumeSource glusterfs) {
    this.glusterfs = glusterfs;
  }

  public IoK8sKubernetesPkgApiV1Volume hostPath(IoK8sKubernetesPkgApiV1HostPathVolumeSource hostPath) {
    this.hostPath = hostPath;
    return this;
  }

   /**
   * HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @return hostPath
  **/
  @ApiModelProperty(value = "HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath")
  public IoK8sKubernetesPkgApiV1HostPathVolumeSource getHostPath() {
    return hostPath;
  }

  public void setHostPath(IoK8sKubernetesPkgApiV1HostPathVolumeSource hostPath) {
    this.hostPath = hostPath;
  }

  public IoK8sKubernetesPkgApiV1Volume iscsi(IoK8sKubernetesPkgApiV1ISCSIVolumeSource iscsi) {
    this.iscsi = iscsi;
    return this;
  }

   /**
   * ISCSI represents an ISCSI Disk resource that is attached to a kubelet&#39;s host machine and then exposed to the pod. More info: https://releases.k8s.io/HEAD/examples/volumes/iscsi/README.md
   * @return iscsi
  **/
  @ApiModelProperty(value = "ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://releases.k8s.io/HEAD/examples/volumes/iscsi/README.md")
  public IoK8sKubernetesPkgApiV1ISCSIVolumeSource getIscsi() {
    return iscsi;
  }

  public void setIscsi(IoK8sKubernetesPkgApiV1ISCSIVolumeSource iscsi) {
    this.iscsi = iscsi;
  }

  public IoK8sKubernetesPkgApiV1Volume name(String name) {
    this.name = name;
    return this;
  }

   /**
   * Volume&#39;s name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * @return name
  **/
  @ApiModelProperty(required = true, value = "Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public IoK8sKubernetesPkgApiV1Volume nfs(IoK8sKubernetesPkgApiV1NFSVolumeSource nfs) {
    this.nfs = nfs;
    return this;
  }

   /**
   * NFS represents an NFS mount on the host that shares a pod&#39;s lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * @return nfs
  **/
  @ApiModelProperty(value = "NFS represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs")
  public IoK8sKubernetesPkgApiV1NFSVolumeSource getNfs() {
    return nfs;
  }

  public void setNfs(IoK8sKubernetesPkgApiV1NFSVolumeSource nfs) {
    this.nfs = nfs;
  }

  public IoK8sKubernetesPkgApiV1Volume persistentVolumeClaim(IoK8sKubernetesPkgApiV1PersistentVolumeClaimVolumeSource persistentVolumeClaim) {
    this.persistentVolumeClaim = persistentVolumeClaim;
    return this;
  }

   /**
   * PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   * @return persistentVolumeClaim
  **/
  @ApiModelProperty(value = "PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims")
  public IoK8sKubernetesPkgApiV1PersistentVolumeClaimVolumeSource getPersistentVolumeClaim() {
    return persistentVolumeClaim;
  }

  public void setPersistentVolumeClaim(IoK8sKubernetesPkgApiV1PersistentVolumeClaimVolumeSource persistentVolumeClaim) {
    this.persistentVolumeClaim = persistentVolumeClaim;
  }

  public IoK8sKubernetesPkgApiV1Volume photonPersistentDisk(IoK8sKubernetesPkgApiV1PhotonPersistentDiskVolumeSource photonPersistentDisk) {
    this.photonPersistentDisk = photonPersistentDisk;
    return this;
  }

   /**
   * PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   * @return photonPersistentDisk
  **/
  @ApiModelProperty(value = "PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine")
  public IoK8sKubernetesPkgApiV1PhotonPersistentDiskVolumeSource getPhotonPersistentDisk() {
    return photonPersistentDisk;
  }

  public void setPhotonPersistentDisk(IoK8sKubernetesPkgApiV1PhotonPersistentDiskVolumeSource photonPersistentDisk) {
    this.photonPersistentDisk = photonPersistentDisk;
  }

  public IoK8sKubernetesPkgApiV1Volume portworxVolume(IoK8sKubernetesPkgApiV1PortworxVolumeSource portworxVolume) {
    this.portworxVolume = portworxVolume;
    return this;
  }

   /**
   * PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
   * @return portworxVolume
  **/
  @ApiModelProperty(value = "PortworxVolume represents a portworx volume attached and mounted on kubelets host machine")
  public IoK8sKubernetesPkgApiV1PortworxVolumeSource getPortworxVolume() {
    return portworxVolume;
  }

  public void setPortworxVolume(IoK8sKubernetesPkgApiV1PortworxVolumeSource portworxVolume) {
    this.portworxVolume = portworxVolume;
  }

  public IoK8sKubernetesPkgApiV1Volume projected(IoK8sKubernetesPkgApiV1ProjectedVolumeSource projected) {
    this.projected = projected;
    return this;
  }

   /**
   * Items for all in one resources secrets, configmaps, and downward API
   * @return projected
  **/
  @ApiModelProperty(value = "Items for all in one resources secrets, configmaps, and downward API")
  public IoK8sKubernetesPkgApiV1ProjectedVolumeSource getProjected() {
    return projected;
  }

  public void setProjected(IoK8sKubernetesPkgApiV1ProjectedVolumeSource projected) {
    this.projected = projected;
  }

  public IoK8sKubernetesPkgApiV1Volume quobyte(IoK8sKubernetesPkgApiV1QuobyteVolumeSource quobyte) {
    this.quobyte = quobyte;
    return this;
  }

   /**
   * Quobyte represents a Quobyte mount on the host that shares a pod&#39;s lifetime
   * @return quobyte
  **/
  @ApiModelProperty(value = "Quobyte represents a Quobyte mount on the host that shares a pod's lifetime")
  public IoK8sKubernetesPkgApiV1QuobyteVolumeSource getQuobyte() {
    return quobyte;
  }

  public void setQuobyte(IoK8sKubernetesPkgApiV1QuobyteVolumeSource quobyte) {
    this.quobyte = quobyte;
  }

  public IoK8sKubernetesPkgApiV1Volume rbd(IoK8sKubernetesPkgApiV1RBDVolumeSource rbd) {
    this.rbd = rbd;
    return this;
  }

   /**
   * RBD represents a Rados Block Device mount on the host that shares a pod&#39;s lifetime. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md
   * @return rbd
  **/
  @ApiModelProperty(value = "RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md")
  public IoK8sKubernetesPkgApiV1RBDVolumeSource getRbd() {
    return rbd;
  }

  public void setRbd(IoK8sKubernetesPkgApiV1RBDVolumeSource rbd) {
    this.rbd = rbd;
  }

  public IoK8sKubernetesPkgApiV1Volume scaleIO(IoK8sKubernetesPkgApiV1ScaleIOVolumeSource scaleIO) {
    this.scaleIO = scaleIO;
    return this;
  }

   /**
   * ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   * @return scaleIO
  **/
  @ApiModelProperty(value = "ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.")
  public IoK8sKubernetesPkgApiV1ScaleIOVolumeSource getScaleIO() {
    return scaleIO;
  }

  public void setScaleIO(IoK8sKubernetesPkgApiV1ScaleIOVolumeSource scaleIO) {
    this.scaleIO = scaleIO;
  }

  public IoK8sKubernetesPkgApiV1Volume secret(IoK8sKubernetesPkgApiV1SecretVolumeSource secret) {
    this.secret = secret;
    return this;
  }

   /**
   * Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   * @return secret
  **/
  @ApiModelProperty(value = "Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret")
  public IoK8sKubernetesPkgApiV1SecretVolumeSource getSecret() {
    return secret;
  }

  public void setSecret(IoK8sKubernetesPkgApiV1SecretVolumeSource secret) {
    this.secret = secret;
  }

  public IoK8sKubernetesPkgApiV1Volume storageos(IoK8sKubernetesPkgApiV1StorageOSVolumeSource storageos) {
    this.storageos = storageos;
    return this;
  }

   /**
   * StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   * @return storageos
  **/
  @ApiModelProperty(value = "StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.")
  public IoK8sKubernetesPkgApiV1StorageOSVolumeSource getStorageos() {
    return storageos;
  }

  public void setStorageos(IoK8sKubernetesPkgApiV1StorageOSVolumeSource storageos) {
    this.storageos = storageos;
  }

  public IoK8sKubernetesPkgApiV1Volume vsphereVolume(IoK8sKubernetesPkgApiV1VsphereVirtualDiskVolumeSource vsphereVolume) {
    this.vsphereVolume = vsphereVolume;
    return this;
  }

   /**
   * VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   * @return vsphereVolume
  **/
  @ApiModelProperty(value = "VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine")
  public IoK8sKubernetesPkgApiV1VsphereVirtualDiskVolumeSource getVsphereVolume() {
    return vsphereVolume;
  }

  public void setVsphereVolume(IoK8sKubernetesPkgApiV1VsphereVirtualDiskVolumeSource vsphereVolume) {
    this.vsphereVolume = vsphereVolume;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    IoK8sKubernetesPkgApiV1Volume ioK8sKubernetesPkgApiV1Volume = (IoK8sKubernetesPkgApiV1Volume) o;
    return Objects.equals(this.awsElasticBlockStore, ioK8sKubernetesPkgApiV1Volume.awsElasticBlockStore) &&
        Objects.equals(this.azureDisk, ioK8sKubernetesPkgApiV1Volume.azureDisk) &&
        Objects.equals(this.azureFile, ioK8sKubernetesPkgApiV1Volume.azureFile) &&
        Objects.equals(this.cephfs, ioK8sKubernetesPkgApiV1Volume.cephfs) &&
        Objects.equals(this.cinder, ioK8sKubernetesPkgApiV1Volume.cinder) &&
        Objects.equals(this.configMap, ioK8sKubernetesPkgApiV1Volume.configMap) &&
        Objects.equals(this.downwardAPI, ioK8sKubernetesPkgApiV1Volume.downwardAPI) &&
        Objects.equals(this.emptyDir, ioK8sKubernetesPkgApiV1Volume.emptyDir) &&
        Objects.equals(this.fc, ioK8sKubernetesPkgApiV1Volume.fc) &&
        Objects.equals(this.flexVolume, ioK8sKubernetesPkgApiV1Volume.flexVolume) &&
        Objects.equals(this.flocker, ioK8sKubernetesPkgApiV1Volume.flocker) &&
        Objects.equals(this.gcePersistentDisk, ioK8sKubernetesPkgApiV1Volume.gcePersistentDisk) &&
        Objects.equals(this.gitRepo, ioK8sKubernetesPkgApiV1Volume.gitRepo) &&
        Objects.equals(this.glusterfs, ioK8sKubernetesPkgApiV1Volume.glusterfs) &&
        Objects.equals(this.hostPath, ioK8sKubernetesPkgApiV1Volume.hostPath) &&
        Objects.equals(this.iscsi, ioK8sKubernetesPkgApiV1Volume.iscsi) &&
        Objects.equals(this.name, ioK8sKubernetesPkgApiV1Volume.name) &&
        Objects.equals(this.nfs, ioK8sKubernetesPkgApiV1Volume.nfs) &&
        Objects.equals(this.persistentVolumeClaim, ioK8sKubernetesPkgApiV1Volume.persistentVolumeClaim) &&
        Objects.equals(this.photonPersistentDisk, ioK8sKubernetesPkgApiV1Volume.photonPersistentDisk) &&
        Objects.equals(this.portworxVolume, ioK8sKubernetesPkgApiV1Volume.portworxVolume) &&
        Objects.equals(this.projected, ioK8sKubernetesPkgApiV1Volume.projected) &&
        Objects.equals(this.quobyte, ioK8sKubernetesPkgApiV1Volume.quobyte) &&
        Objects.equals(this.rbd, ioK8sKubernetesPkgApiV1Volume.rbd) &&
        Objects.equals(this.scaleIO, ioK8sKubernetesPkgApiV1Volume.scaleIO) &&
        Objects.equals(this.secret, ioK8sKubernetesPkgApiV1Volume.secret) &&
        Objects.equals(this.storageos, ioK8sKubernetesPkgApiV1Volume.storageos) &&
        Objects.equals(this.vsphereVolume, ioK8sKubernetesPkgApiV1Volume.vsphereVolume);
  }

  @Override
  public int hashCode() {
    return Objects.hash(awsElasticBlockStore, azureDisk, azureFile, cephfs, cinder, configMap, downwardAPI, emptyDir, fc, flexVolume, flocker, gcePersistentDisk, gitRepo, glusterfs, hostPath, iscsi, name, nfs, persistentVolumeClaim, photonPersistentDisk, portworxVolume, projected, quobyte, rbd, scaleIO, secret, storageos, vsphereVolume);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class IoK8sKubernetesPkgApiV1Volume {\n");
    
    sb.append("    awsElasticBlockStore: ").append(toIndentedString(awsElasticBlockStore)).append("\n");
    sb.append("    azureDisk: ").append(toIndentedString(azureDisk)).append("\n");
    sb.append("    azureFile: ").append(toIndentedString(azureFile)).append("\n");
    sb.append("    cephfs: ").append(toIndentedString(cephfs)).append("\n");
    sb.append("    cinder: ").append(toIndentedString(cinder)).append("\n");
    sb.append("    configMap: ").append(toIndentedString(configMap)).append("\n");
    sb.append("    downwardAPI: ").append(toIndentedString(downwardAPI)).append("\n");
    sb.append("    emptyDir: ").append(toIndentedString(emptyDir)).append("\n");
    sb.append("    fc: ").append(toIndentedString(fc)).append("\n");
    sb.append("    flexVolume: ").append(toIndentedString(flexVolume)).append("\n");
    sb.append("    flocker: ").append(toIndentedString(flocker)).append("\n");
    sb.append("    gcePersistentDisk: ").append(toIndentedString(gcePersistentDisk)).append("\n");
    sb.append("    gitRepo: ").append(toIndentedString(gitRepo)).append("\n");
    sb.append("    glusterfs: ").append(toIndentedString(glusterfs)).append("\n");
    sb.append("    hostPath: ").append(toIndentedString(hostPath)).append("\n");
    sb.append("    iscsi: ").append(toIndentedString(iscsi)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    nfs: ").append(toIndentedString(nfs)).append("\n");
    sb.append("    persistentVolumeClaim: ").append(toIndentedString(persistentVolumeClaim)).append("\n");
    sb.append("    photonPersistentDisk: ").append(toIndentedString(photonPersistentDisk)).append("\n");
    sb.append("    portworxVolume: ").append(toIndentedString(portworxVolume)).append("\n");
    sb.append("    projected: ").append(toIndentedString(projected)).append("\n");
    sb.append("    quobyte: ").append(toIndentedString(quobyte)).append("\n");
    sb.append("    rbd: ").append(toIndentedString(rbd)).append("\n");
    sb.append("    scaleIO: ").append(toIndentedString(scaleIO)).append("\n");
    sb.append("    secret: ").append(toIndentedString(secret)).append("\n");
    sb.append("    storageos: ").append(toIndentedString(storageos)).append("\n");
    sb.append("    vsphereVolume: ").append(toIndentedString(vsphereVolume)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
  
}

