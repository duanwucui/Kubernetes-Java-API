/*
 * Kubernetes
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.7.9
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.swagger.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import io.swagger.client.model.IoK8sKubernetesPkgApiV1AWSElasticBlockStoreVolumeSource;
import io.swagger.client.model.IoK8sKubernetesPkgApiV1AzureDiskVolumeSource;
import io.swagger.client.model.IoK8sKubernetesPkgApiV1AzureFileVolumeSource;
import io.swagger.client.model.IoK8sKubernetesPkgApiV1CephFSVolumeSource;
import io.swagger.client.model.IoK8sKubernetesPkgApiV1CinderVolumeSource;
import io.swagger.client.model.IoK8sKubernetesPkgApiV1FCVolumeSource;
import io.swagger.client.model.IoK8sKubernetesPkgApiV1FlexVolumeSource;
import io.swagger.client.model.IoK8sKubernetesPkgApiV1FlockerVolumeSource;
import io.swagger.client.model.IoK8sKubernetesPkgApiV1GCEPersistentDiskVolumeSource;
import io.swagger.client.model.IoK8sKubernetesPkgApiV1GlusterfsVolumeSource;
import io.swagger.client.model.IoK8sKubernetesPkgApiV1HostPathVolumeSource;
import io.swagger.client.model.IoK8sKubernetesPkgApiV1ISCSIVolumeSource;
import io.swagger.client.model.IoK8sKubernetesPkgApiV1LocalVolumeSource;
import io.swagger.client.model.IoK8sKubernetesPkgApiV1NFSVolumeSource;
import io.swagger.client.model.IoK8sKubernetesPkgApiV1ObjectReference;
import io.swagger.client.model.IoK8sKubernetesPkgApiV1PhotonPersistentDiskVolumeSource;
import io.swagger.client.model.IoK8sKubernetesPkgApiV1PortworxVolumeSource;
import io.swagger.client.model.IoK8sKubernetesPkgApiV1QuobyteVolumeSource;
import io.swagger.client.model.IoK8sKubernetesPkgApiV1RBDVolumeSource;
import io.swagger.client.model.IoK8sKubernetesPkgApiV1ScaleIOVolumeSource;
import io.swagger.client.model.IoK8sKubernetesPkgApiV1StorageOSPersistentVolumeSource;
import io.swagger.client.model.IoK8sKubernetesPkgApiV1VsphereVirtualDiskVolumeSource;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * PersistentVolumeSpec is the specification of a persistent volume.
 */
@ApiModel(description = "PersistentVolumeSpec is the specification of a persistent volume.")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2017-11-16T15:42:22.208Z")
public class IoK8sKubernetesPkgApiV1PersistentVolumeSpec {
  @SerializedName("accessModes")
  private List<String> accessModes = null;

  @SerializedName("awsElasticBlockStore")
  private IoK8sKubernetesPkgApiV1AWSElasticBlockStoreVolumeSource awsElasticBlockStore = null;

  @SerializedName("azureDisk")
  private IoK8sKubernetesPkgApiV1AzureDiskVolumeSource azureDisk = null;

  @SerializedName("azureFile")
  private IoK8sKubernetesPkgApiV1AzureFileVolumeSource azureFile = null;

  @SerializedName("capacity")
  private Map<String, String> capacity = null;

  @SerializedName("cephfs")
  private IoK8sKubernetesPkgApiV1CephFSVolumeSource cephfs = null;

  @SerializedName("cinder")
  private IoK8sKubernetesPkgApiV1CinderVolumeSource cinder = null;

  @SerializedName("claimRef")
  private IoK8sKubernetesPkgApiV1ObjectReference claimRef = null;

  @SerializedName("fc")
  private IoK8sKubernetesPkgApiV1FCVolumeSource fc = null;

  @SerializedName("flexVolume")
  private IoK8sKubernetesPkgApiV1FlexVolumeSource flexVolume = null;

  @SerializedName("flocker")
  private IoK8sKubernetesPkgApiV1FlockerVolumeSource flocker = null;

  @SerializedName("gcePersistentDisk")
  private IoK8sKubernetesPkgApiV1GCEPersistentDiskVolumeSource gcePersistentDisk = null;

  @SerializedName("glusterfs")
  private IoK8sKubernetesPkgApiV1GlusterfsVolumeSource glusterfs = null;

  @SerializedName("hostPath")
  private IoK8sKubernetesPkgApiV1HostPathVolumeSource hostPath = null;

  @SerializedName("iscsi")
  private IoK8sKubernetesPkgApiV1ISCSIVolumeSource iscsi = null;

  @SerializedName("local")
  private IoK8sKubernetesPkgApiV1LocalVolumeSource local = null;

  @SerializedName("nfs")
  private IoK8sKubernetesPkgApiV1NFSVolumeSource nfs = null;

  @SerializedName("persistentVolumeReclaimPolicy")
  private String persistentVolumeReclaimPolicy = null;

  @SerializedName("photonPersistentDisk")
  private IoK8sKubernetesPkgApiV1PhotonPersistentDiskVolumeSource photonPersistentDisk = null;

  @SerializedName("portworxVolume")
  private IoK8sKubernetesPkgApiV1PortworxVolumeSource portworxVolume = null;

  @SerializedName("quobyte")
  private IoK8sKubernetesPkgApiV1QuobyteVolumeSource quobyte = null;

  @SerializedName("rbd")
  private IoK8sKubernetesPkgApiV1RBDVolumeSource rbd = null;

  @SerializedName("scaleIO")
  private IoK8sKubernetesPkgApiV1ScaleIOVolumeSource scaleIO = null;

  @SerializedName("storageClassName")
  private String storageClassName = null;

  @SerializedName("storageos")
  private IoK8sKubernetesPkgApiV1StorageOSPersistentVolumeSource storageos = null;

  @SerializedName("vsphereVolume")
  private IoK8sKubernetesPkgApiV1VsphereVirtualDiskVolumeSource vsphereVolume = null;

  public IoK8sKubernetesPkgApiV1PersistentVolumeSpec accessModes(List<String> accessModes) {
    this.accessModes = accessModes;
    return this;
  }

  public IoK8sKubernetesPkgApiV1PersistentVolumeSpec addAccessModesItem(String accessModesItem) {
    if (this.accessModes == null) {
      this.accessModes = new ArrayList<String>();
    }
    this.accessModes.add(accessModesItem);
    return this;
  }

   /**
   * AccessModes contains all ways the volume can be mounted. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes
   * @return accessModes
  **/
  @ApiModelProperty(value = "AccessModes contains all ways the volume can be mounted. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes")
  public List<String> getAccessModes() {
    return accessModes;
  }

  public void setAccessModes(List<String> accessModes) {
    this.accessModes = accessModes;
  }

  public IoK8sKubernetesPkgApiV1PersistentVolumeSpec awsElasticBlockStore(IoK8sKubernetesPkgApiV1AWSElasticBlockStoreVolumeSource awsElasticBlockStore) {
    this.awsElasticBlockStore = awsElasticBlockStore;
    return this;
  }

   /**
   * AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet&#39;s host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   * @return awsElasticBlockStore
  **/
  @ApiModelProperty(value = "AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore")
  public IoK8sKubernetesPkgApiV1AWSElasticBlockStoreVolumeSource getAwsElasticBlockStore() {
    return awsElasticBlockStore;
  }

  public void setAwsElasticBlockStore(IoK8sKubernetesPkgApiV1AWSElasticBlockStoreVolumeSource awsElasticBlockStore) {
    this.awsElasticBlockStore = awsElasticBlockStore;
  }

  public IoK8sKubernetesPkgApiV1PersistentVolumeSpec azureDisk(IoK8sKubernetesPkgApiV1AzureDiskVolumeSource azureDisk) {
    this.azureDisk = azureDisk;
    return this;
  }

   /**
   * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   * @return azureDisk
  **/
  @ApiModelProperty(value = "AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.")
  public IoK8sKubernetesPkgApiV1AzureDiskVolumeSource getAzureDisk() {
    return azureDisk;
  }

  public void setAzureDisk(IoK8sKubernetesPkgApiV1AzureDiskVolumeSource azureDisk) {
    this.azureDisk = azureDisk;
  }

  public IoK8sKubernetesPkgApiV1PersistentVolumeSpec azureFile(IoK8sKubernetesPkgApiV1AzureFileVolumeSource azureFile) {
    this.azureFile = azureFile;
    return this;
  }

   /**
   * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
   * @return azureFile
  **/
  @ApiModelProperty(value = "AzureFile represents an Azure File Service mount on the host and bind mount to the pod.")
  public IoK8sKubernetesPkgApiV1AzureFileVolumeSource getAzureFile() {
    return azureFile;
  }

  public void setAzureFile(IoK8sKubernetesPkgApiV1AzureFileVolumeSource azureFile) {
    this.azureFile = azureFile;
  }

  public IoK8sKubernetesPkgApiV1PersistentVolumeSpec capacity(Map<String, String> capacity) {
    this.capacity = capacity;
    return this;
  }

  public IoK8sKubernetesPkgApiV1PersistentVolumeSpec putCapacityItem(String key, String capacityItem) {
    if (this.capacity == null) {
      this.capacity = new HashMap<String, String>();
    }
    this.capacity.put(key, capacityItem);
    return this;
  }

   /**
   * A description of the persistent volume&#39;s resources and capacity. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
   * @return capacity
  **/
  @ApiModelProperty(value = "A description of the persistent volume's resources and capacity. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity")
  public Map<String, String> getCapacity() {
    return capacity;
  }

  public void setCapacity(Map<String, String> capacity) {
    this.capacity = capacity;
  }

  public IoK8sKubernetesPkgApiV1PersistentVolumeSpec cephfs(IoK8sKubernetesPkgApiV1CephFSVolumeSource cephfs) {
    this.cephfs = cephfs;
    return this;
  }

   /**
   * CephFS represents a Ceph FS mount on the host that shares a pod&#39;s lifetime
   * @return cephfs
  **/
  @ApiModelProperty(value = "CephFS represents a Ceph FS mount on the host that shares a pod's lifetime")
  public IoK8sKubernetesPkgApiV1CephFSVolumeSource getCephfs() {
    return cephfs;
  }

  public void setCephfs(IoK8sKubernetesPkgApiV1CephFSVolumeSource cephfs) {
    this.cephfs = cephfs;
  }

  public IoK8sKubernetesPkgApiV1PersistentVolumeSpec cinder(IoK8sKubernetesPkgApiV1CinderVolumeSource cinder) {
    this.cinder = cinder;
    return this;
  }

   /**
   * Cinder represents a cinder volume attached and mounted on kubelets host machine More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
   * @return cinder
  **/
  @ApiModelProperty(value = "Cinder represents a cinder volume attached and mounted on kubelets host machine More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md")
  public IoK8sKubernetesPkgApiV1CinderVolumeSource getCinder() {
    return cinder;
  }

  public void setCinder(IoK8sKubernetesPkgApiV1CinderVolumeSource cinder) {
    this.cinder = cinder;
  }

  public IoK8sKubernetesPkgApiV1PersistentVolumeSpec claimRef(IoK8sKubernetesPkgApiV1ObjectReference claimRef) {
    this.claimRef = claimRef;
    return this;
  }

   /**
   * ClaimRef is part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. claim.VolumeName is the authoritative bind between PV and PVC. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding
   * @return claimRef
  **/
  @ApiModelProperty(value = "ClaimRef is part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. claim.VolumeName is the authoritative bind between PV and PVC. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding")
  public IoK8sKubernetesPkgApiV1ObjectReference getClaimRef() {
    return claimRef;
  }

  public void setClaimRef(IoK8sKubernetesPkgApiV1ObjectReference claimRef) {
    this.claimRef = claimRef;
  }

  public IoK8sKubernetesPkgApiV1PersistentVolumeSpec fc(IoK8sKubernetesPkgApiV1FCVolumeSource fc) {
    this.fc = fc;
    return this;
  }

   /**
   * FC represents a Fibre Channel resource that is attached to a kubelet&#39;s host machine and then exposed to the pod.
   * @return fc
  **/
  @ApiModelProperty(value = "FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.")
  public IoK8sKubernetesPkgApiV1FCVolumeSource getFc() {
    return fc;
  }

  public void setFc(IoK8sKubernetesPkgApiV1FCVolumeSource fc) {
    this.fc = fc;
  }

  public IoK8sKubernetesPkgApiV1PersistentVolumeSpec flexVolume(IoK8sKubernetesPkgApiV1FlexVolumeSource flexVolume) {
    this.flexVolume = flexVolume;
    return this;
  }

   /**
   * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin. This is an alpha feature and may change in future.
   * @return flexVolume
  **/
  @ApiModelProperty(value = "FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin. This is an alpha feature and may change in future.")
  public IoK8sKubernetesPkgApiV1FlexVolumeSource getFlexVolume() {
    return flexVolume;
  }

  public void setFlexVolume(IoK8sKubernetesPkgApiV1FlexVolumeSource flexVolume) {
    this.flexVolume = flexVolume;
  }

  public IoK8sKubernetesPkgApiV1PersistentVolumeSpec flocker(IoK8sKubernetesPkgApiV1FlockerVolumeSource flocker) {
    this.flocker = flocker;
    return this;
  }

   /**
   * Flocker represents a Flocker volume attached to a kubelet&#39;s host machine and exposed to the pod for its usage. This depends on the Flocker control service being running
   * @return flocker
  **/
  @ApiModelProperty(value = "Flocker represents a Flocker volume attached to a kubelet's host machine and exposed to the pod for its usage. This depends on the Flocker control service being running")
  public IoK8sKubernetesPkgApiV1FlockerVolumeSource getFlocker() {
    return flocker;
  }

  public void setFlocker(IoK8sKubernetesPkgApiV1FlockerVolumeSource flocker) {
    this.flocker = flocker;
  }

  public IoK8sKubernetesPkgApiV1PersistentVolumeSpec gcePersistentDisk(IoK8sKubernetesPkgApiV1GCEPersistentDiskVolumeSource gcePersistentDisk) {
    this.gcePersistentDisk = gcePersistentDisk;
    return this;
  }

   /**
   * GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet&#39;s host machine and then exposed to the pod. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * @return gcePersistentDisk
  **/
  @ApiModelProperty(value = "GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk")
  public IoK8sKubernetesPkgApiV1GCEPersistentDiskVolumeSource getGcePersistentDisk() {
    return gcePersistentDisk;
  }

  public void setGcePersistentDisk(IoK8sKubernetesPkgApiV1GCEPersistentDiskVolumeSource gcePersistentDisk) {
    this.gcePersistentDisk = gcePersistentDisk;
  }

  public IoK8sKubernetesPkgApiV1PersistentVolumeSpec glusterfs(IoK8sKubernetesPkgApiV1GlusterfsVolumeSource glusterfs) {
    this.glusterfs = glusterfs;
    return this;
  }

   /**
   * Glusterfs represents a Glusterfs volume that is attached to a host and exposed to the pod. Provisioned by an admin. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md
   * @return glusterfs
  **/
  @ApiModelProperty(value = "Glusterfs represents a Glusterfs volume that is attached to a host and exposed to the pod. Provisioned by an admin. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md")
  public IoK8sKubernetesPkgApiV1GlusterfsVolumeSource getGlusterfs() {
    return glusterfs;
  }

  public void setGlusterfs(IoK8sKubernetesPkgApiV1GlusterfsVolumeSource glusterfs) {
    this.glusterfs = glusterfs;
  }

  public IoK8sKubernetesPkgApiV1PersistentVolumeSpec hostPath(IoK8sKubernetesPkgApiV1HostPathVolumeSource hostPath) {
    this.hostPath = hostPath;
    return this;
  }

   /**
   * HostPath represents a directory on the host. Provisioned by a developer or tester. This is useful for single-node development and testing only! On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @return hostPath
  **/
  @ApiModelProperty(value = "HostPath represents a directory on the host. Provisioned by a developer or tester. This is useful for single-node development and testing only! On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath")
  public IoK8sKubernetesPkgApiV1HostPathVolumeSource getHostPath() {
    return hostPath;
  }

  public void setHostPath(IoK8sKubernetesPkgApiV1HostPathVolumeSource hostPath) {
    this.hostPath = hostPath;
  }

  public IoK8sKubernetesPkgApiV1PersistentVolumeSpec iscsi(IoK8sKubernetesPkgApiV1ISCSIVolumeSource iscsi) {
    this.iscsi = iscsi;
    return this;
  }

   /**
   * ISCSI represents an ISCSI Disk resource that is attached to a kubelet&#39;s host machine and then exposed to the pod. Provisioned by an admin.
   * @return iscsi
  **/
  @ApiModelProperty(value = "ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. Provisioned by an admin.")
  public IoK8sKubernetesPkgApiV1ISCSIVolumeSource getIscsi() {
    return iscsi;
  }

  public void setIscsi(IoK8sKubernetesPkgApiV1ISCSIVolumeSource iscsi) {
    this.iscsi = iscsi;
  }

  public IoK8sKubernetesPkgApiV1PersistentVolumeSpec local(IoK8sKubernetesPkgApiV1LocalVolumeSource local) {
    this.local = local;
    return this;
  }

   /**
   * Local represents directly-attached storage with node affinity
   * @return local
  **/
  @ApiModelProperty(value = "Local represents directly-attached storage with node affinity")
  public IoK8sKubernetesPkgApiV1LocalVolumeSource getLocal() {
    return local;
  }

  public void setLocal(IoK8sKubernetesPkgApiV1LocalVolumeSource local) {
    this.local = local;
  }

  public IoK8sKubernetesPkgApiV1PersistentVolumeSpec nfs(IoK8sKubernetesPkgApiV1NFSVolumeSource nfs) {
    this.nfs = nfs;
    return this;
  }

   /**
   * NFS represents an NFS mount on the host. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * @return nfs
  **/
  @ApiModelProperty(value = "NFS represents an NFS mount on the host. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs")
  public IoK8sKubernetesPkgApiV1NFSVolumeSource getNfs() {
    return nfs;
  }

  public void setNfs(IoK8sKubernetesPkgApiV1NFSVolumeSource nfs) {
    this.nfs = nfs;
  }

  public IoK8sKubernetesPkgApiV1PersistentVolumeSpec persistentVolumeReclaimPolicy(String persistentVolumeReclaimPolicy) {
    this.persistentVolumeReclaimPolicy = persistentVolumeReclaimPolicy;
    return this;
  }

   /**
   * What happens to a persistent volume when released from its claim. Valid options are Retain (default) and Recycle. Recycling must be supported by the volume plugin underlying this persistent volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming
   * @return persistentVolumeReclaimPolicy
  **/
  @ApiModelProperty(value = "What happens to a persistent volume when released from its claim. Valid options are Retain (default) and Recycle. Recycling must be supported by the volume plugin underlying this persistent volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming")
  public String getPersistentVolumeReclaimPolicy() {
    return persistentVolumeReclaimPolicy;
  }

  public void setPersistentVolumeReclaimPolicy(String persistentVolumeReclaimPolicy) {
    this.persistentVolumeReclaimPolicy = persistentVolumeReclaimPolicy;
  }

  public IoK8sKubernetesPkgApiV1PersistentVolumeSpec photonPersistentDisk(IoK8sKubernetesPkgApiV1PhotonPersistentDiskVolumeSource photonPersistentDisk) {
    this.photonPersistentDisk = photonPersistentDisk;
    return this;
  }

   /**
   * PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   * @return photonPersistentDisk
  **/
  @ApiModelProperty(value = "PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine")
  public IoK8sKubernetesPkgApiV1PhotonPersistentDiskVolumeSource getPhotonPersistentDisk() {
    return photonPersistentDisk;
  }

  public void setPhotonPersistentDisk(IoK8sKubernetesPkgApiV1PhotonPersistentDiskVolumeSource photonPersistentDisk) {
    this.photonPersistentDisk = photonPersistentDisk;
  }

  public IoK8sKubernetesPkgApiV1PersistentVolumeSpec portworxVolume(IoK8sKubernetesPkgApiV1PortworxVolumeSource portworxVolume) {
    this.portworxVolume = portworxVolume;
    return this;
  }

   /**
   * PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
   * @return portworxVolume
  **/
  @ApiModelProperty(value = "PortworxVolume represents a portworx volume attached and mounted on kubelets host machine")
  public IoK8sKubernetesPkgApiV1PortworxVolumeSource getPortworxVolume() {
    return portworxVolume;
  }

  public void setPortworxVolume(IoK8sKubernetesPkgApiV1PortworxVolumeSource portworxVolume) {
    this.portworxVolume = portworxVolume;
  }

  public IoK8sKubernetesPkgApiV1PersistentVolumeSpec quobyte(IoK8sKubernetesPkgApiV1QuobyteVolumeSource quobyte) {
    this.quobyte = quobyte;
    return this;
  }

   /**
   * Quobyte represents a Quobyte mount on the host that shares a pod&#39;s lifetime
   * @return quobyte
  **/
  @ApiModelProperty(value = "Quobyte represents a Quobyte mount on the host that shares a pod's lifetime")
  public IoK8sKubernetesPkgApiV1QuobyteVolumeSource getQuobyte() {
    return quobyte;
  }

  public void setQuobyte(IoK8sKubernetesPkgApiV1QuobyteVolumeSource quobyte) {
    this.quobyte = quobyte;
  }

  public IoK8sKubernetesPkgApiV1PersistentVolumeSpec rbd(IoK8sKubernetesPkgApiV1RBDVolumeSource rbd) {
    this.rbd = rbd;
    return this;
  }

   /**
   * RBD represents a Rados Block Device mount on the host that shares a pod&#39;s lifetime. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md
   * @return rbd
  **/
  @ApiModelProperty(value = "RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md")
  public IoK8sKubernetesPkgApiV1RBDVolumeSource getRbd() {
    return rbd;
  }

  public void setRbd(IoK8sKubernetesPkgApiV1RBDVolumeSource rbd) {
    this.rbd = rbd;
  }

  public IoK8sKubernetesPkgApiV1PersistentVolumeSpec scaleIO(IoK8sKubernetesPkgApiV1ScaleIOVolumeSource scaleIO) {
    this.scaleIO = scaleIO;
    return this;
  }

   /**
   * ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   * @return scaleIO
  **/
  @ApiModelProperty(value = "ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.")
  public IoK8sKubernetesPkgApiV1ScaleIOVolumeSource getScaleIO() {
    return scaleIO;
  }

  public void setScaleIO(IoK8sKubernetesPkgApiV1ScaleIOVolumeSource scaleIO) {
    this.scaleIO = scaleIO;
  }

  public IoK8sKubernetesPkgApiV1PersistentVolumeSpec storageClassName(String storageClassName) {
    this.storageClassName = storageClassName;
    return this;
  }

   /**
   * Name of StorageClass to which this persistent volume belongs. Empty value means that this volume does not belong to any StorageClass.
   * @return storageClassName
  **/
  @ApiModelProperty(value = "Name of StorageClass to which this persistent volume belongs. Empty value means that this volume does not belong to any StorageClass.")
  public String getStorageClassName() {
    return storageClassName;
  }

  public void setStorageClassName(String storageClassName) {
    this.storageClassName = storageClassName;
  }

  public IoK8sKubernetesPkgApiV1PersistentVolumeSpec storageos(IoK8sKubernetesPkgApiV1StorageOSPersistentVolumeSource storageos) {
    this.storageos = storageos;
    return this;
  }

   /**
   * StorageOS represents a StorageOS volume that is attached to the kubelet&#39;s host machine and mounted into the pod More info: https://releases.k8s.io/HEAD/examples/volumes/storageos/README.md
   * @return storageos
  **/
  @ApiModelProperty(value = "StorageOS represents a StorageOS volume that is attached to the kubelet's host machine and mounted into the pod More info: https://releases.k8s.io/HEAD/examples/volumes/storageos/README.md")
  public IoK8sKubernetesPkgApiV1StorageOSPersistentVolumeSource getStorageos() {
    return storageos;
  }

  public void setStorageos(IoK8sKubernetesPkgApiV1StorageOSPersistentVolumeSource storageos) {
    this.storageos = storageos;
  }

  public IoK8sKubernetesPkgApiV1PersistentVolumeSpec vsphereVolume(IoK8sKubernetesPkgApiV1VsphereVirtualDiskVolumeSource vsphereVolume) {
    this.vsphereVolume = vsphereVolume;
    return this;
  }

   /**
   * VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   * @return vsphereVolume
  **/
  @ApiModelProperty(value = "VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine")
  public IoK8sKubernetesPkgApiV1VsphereVirtualDiskVolumeSource getVsphereVolume() {
    return vsphereVolume;
  }

  public void setVsphereVolume(IoK8sKubernetesPkgApiV1VsphereVirtualDiskVolumeSource vsphereVolume) {
    this.vsphereVolume = vsphereVolume;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    IoK8sKubernetesPkgApiV1PersistentVolumeSpec ioK8sKubernetesPkgApiV1PersistentVolumeSpec = (IoK8sKubernetesPkgApiV1PersistentVolumeSpec) o;
    return Objects.equals(this.accessModes, ioK8sKubernetesPkgApiV1PersistentVolumeSpec.accessModes) &&
        Objects.equals(this.awsElasticBlockStore, ioK8sKubernetesPkgApiV1PersistentVolumeSpec.awsElasticBlockStore) &&
        Objects.equals(this.azureDisk, ioK8sKubernetesPkgApiV1PersistentVolumeSpec.azureDisk) &&
        Objects.equals(this.azureFile, ioK8sKubernetesPkgApiV1PersistentVolumeSpec.azureFile) &&
        Objects.equals(this.capacity, ioK8sKubernetesPkgApiV1PersistentVolumeSpec.capacity) &&
        Objects.equals(this.cephfs, ioK8sKubernetesPkgApiV1PersistentVolumeSpec.cephfs) &&
        Objects.equals(this.cinder, ioK8sKubernetesPkgApiV1PersistentVolumeSpec.cinder) &&
        Objects.equals(this.claimRef, ioK8sKubernetesPkgApiV1PersistentVolumeSpec.claimRef) &&
        Objects.equals(this.fc, ioK8sKubernetesPkgApiV1PersistentVolumeSpec.fc) &&
        Objects.equals(this.flexVolume, ioK8sKubernetesPkgApiV1PersistentVolumeSpec.flexVolume) &&
        Objects.equals(this.flocker, ioK8sKubernetesPkgApiV1PersistentVolumeSpec.flocker) &&
        Objects.equals(this.gcePersistentDisk, ioK8sKubernetesPkgApiV1PersistentVolumeSpec.gcePersistentDisk) &&
        Objects.equals(this.glusterfs, ioK8sKubernetesPkgApiV1PersistentVolumeSpec.glusterfs) &&
        Objects.equals(this.hostPath, ioK8sKubernetesPkgApiV1PersistentVolumeSpec.hostPath) &&
        Objects.equals(this.iscsi, ioK8sKubernetesPkgApiV1PersistentVolumeSpec.iscsi) &&
        Objects.equals(this.local, ioK8sKubernetesPkgApiV1PersistentVolumeSpec.local) &&
        Objects.equals(this.nfs, ioK8sKubernetesPkgApiV1PersistentVolumeSpec.nfs) &&
        Objects.equals(this.persistentVolumeReclaimPolicy, ioK8sKubernetesPkgApiV1PersistentVolumeSpec.persistentVolumeReclaimPolicy) &&
        Objects.equals(this.photonPersistentDisk, ioK8sKubernetesPkgApiV1PersistentVolumeSpec.photonPersistentDisk) &&
        Objects.equals(this.portworxVolume, ioK8sKubernetesPkgApiV1PersistentVolumeSpec.portworxVolume) &&
        Objects.equals(this.quobyte, ioK8sKubernetesPkgApiV1PersistentVolumeSpec.quobyte) &&
        Objects.equals(this.rbd, ioK8sKubernetesPkgApiV1PersistentVolumeSpec.rbd) &&
        Objects.equals(this.scaleIO, ioK8sKubernetesPkgApiV1PersistentVolumeSpec.scaleIO) &&
        Objects.equals(this.storageClassName, ioK8sKubernetesPkgApiV1PersistentVolumeSpec.storageClassName) &&
        Objects.equals(this.storageos, ioK8sKubernetesPkgApiV1PersistentVolumeSpec.storageos) &&
        Objects.equals(this.vsphereVolume, ioK8sKubernetesPkgApiV1PersistentVolumeSpec.vsphereVolume);
  }

  @Override
  public int hashCode() {
    return Objects.hash(accessModes, awsElasticBlockStore, azureDisk, azureFile, capacity, cephfs, cinder, claimRef, fc, flexVolume, flocker, gcePersistentDisk, glusterfs, hostPath, iscsi, local, nfs, persistentVolumeReclaimPolicy, photonPersistentDisk, portworxVolume, quobyte, rbd, scaleIO, storageClassName, storageos, vsphereVolume);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class IoK8sKubernetesPkgApiV1PersistentVolumeSpec {\n");
    
    sb.append("    accessModes: ").append(toIndentedString(accessModes)).append("\n");
    sb.append("    awsElasticBlockStore: ").append(toIndentedString(awsElasticBlockStore)).append("\n");
    sb.append("    azureDisk: ").append(toIndentedString(azureDisk)).append("\n");
    sb.append("    azureFile: ").append(toIndentedString(azureFile)).append("\n");
    sb.append("    capacity: ").append(toIndentedString(capacity)).append("\n");
    sb.append("    cephfs: ").append(toIndentedString(cephfs)).append("\n");
    sb.append("    cinder: ").append(toIndentedString(cinder)).append("\n");
    sb.append("    claimRef: ").append(toIndentedString(claimRef)).append("\n");
    sb.append("    fc: ").append(toIndentedString(fc)).append("\n");
    sb.append("    flexVolume: ").append(toIndentedString(flexVolume)).append("\n");
    sb.append("    flocker: ").append(toIndentedString(flocker)).append("\n");
    sb.append("    gcePersistentDisk: ").append(toIndentedString(gcePersistentDisk)).append("\n");
    sb.append("    glusterfs: ").append(toIndentedString(glusterfs)).append("\n");
    sb.append("    hostPath: ").append(toIndentedString(hostPath)).append("\n");
    sb.append("    iscsi: ").append(toIndentedString(iscsi)).append("\n");
    sb.append("    local: ").append(toIndentedString(local)).append("\n");
    sb.append("    nfs: ").append(toIndentedString(nfs)).append("\n");
    sb.append("    persistentVolumeReclaimPolicy: ").append(toIndentedString(persistentVolumeReclaimPolicy)).append("\n");
    sb.append("    photonPersistentDisk: ").append(toIndentedString(photonPersistentDisk)).append("\n");
    sb.append("    portworxVolume: ").append(toIndentedString(portworxVolume)).append("\n");
    sb.append("    quobyte: ").append(toIndentedString(quobyte)).append("\n");
    sb.append("    rbd: ").append(toIndentedString(rbd)).append("\n");
    sb.append("    scaleIO: ").append(toIndentedString(scaleIO)).append("\n");
    sb.append("    storageClassName: ").append(toIndentedString(storageClassName)).append("\n");
    sb.append("    storageos: ").append(toIndentedString(storageos)).append("\n");
    sb.append("    vsphereVolume: ").append(toIndentedString(vsphereVolume)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
  
}

